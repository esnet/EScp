// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum Session_InitOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Session_Init<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Session_Init<'a> {
  type Inner = Session_Init<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Session_Init<'a> {
  pub const VT_VERSION_MAJOR: flatbuffers::VOffsetT = 4;
  pub const VT_VERSION_MINOR: flatbuffers::VOffsetT = 6;
  pub const VT_SESSION_ID: flatbuffers::VOffsetT = 8;
  pub const VT_CRYPTO_KEY: flatbuffers::VOffsetT = 10;
  pub const VT_DO_HASH: flatbuffers::VOffsetT = 12;
  pub const VT_DO_CRYPTO: flatbuffers::VOffsetT = 14;
  pub const VT_DO_VERBOSE: flatbuffers::VOffsetT = 16;
  pub const VT_DO_COMPRESSION: flatbuffers::VOffsetT = 18;
  pub const VT_DO_PRESERVE: flatbuffers::VOffsetT = 20;
  pub const VT_DO_SPARSE: flatbuffers::VOffsetT = 22;
  pub const VT_NO_DIRECT: flatbuffers::VOffsetT = 24;
  pub const VT_IS_ERROR: flatbuffers::VOffsetT = 26;
  pub const VT_LOG_FILE: flatbuffers::VOffsetT = 28;
  pub const VT_MESSAGE: flatbuffers::VOffsetT = 30;
  pub const VT_BIND_INTERFACE: flatbuffers::VOffsetT = 32;
  pub const VT_PORT_START: flatbuffers::VOffsetT = 34;
  pub const VT_PORT_END: flatbuffers::VOffsetT = 36;
  pub const VT_IO_ENGINE: flatbuffers::VOffsetT = 38;
  pub const VT_THREAD_COUNT: flatbuffers::VOffsetT = 40;
  pub const VT_BLOCK_SZ: flatbuffers::VOffsetT = 42;
  pub const VT_IP_MODE: flatbuffers::VOffsetT = 44;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Session_Init { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args Session_InitArgs<'args>
  ) -> flatbuffers::WIPOffset<Session_Init<'bldr>> {
    let mut builder = Session_InitBuilder::new(_fbb);
    builder.add_session_id(args.session_id);
    builder.add_block_sz(args.block_sz);
    builder.add_thread_count(args.thread_count);
    builder.add_io_engine(args.io_engine);
    builder.add_port_end(args.port_end);
    builder.add_port_start(args.port_start);
    if let Some(x) = args.bind_interface { builder.add_bind_interface(x); }
    if let Some(x) = args.message { builder.add_message(x); }
    if let Some(x) = args.log_file { builder.add_log_file(x); }
    if let Some(x) = args.crypto_key { builder.add_crypto_key(x); }
    builder.add_version_minor(args.version_minor);
    builder.add_version_major(args.version_major);
    builder.add_ip_mode(args.ip_mode);
    builder.add_is_error(args.is_error);
    builder.add_no_direct(args.no_direct);
    builder.add_do_sparse(args.do_sparse);
    builder.add_do_preserve(args.do_preserve);
    builder.add_do_compression(args.do_compression);
    builder.add_do_verbose(args.do_verbose);
    builder.add_do_crypto(args.do_crypto);
    builder.add_do_hash(args.do_hash);
    builder.finish()
  }


  #[inline]
  pub fn version_major(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Session_Init::VT_VERSION_MAJOR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn version_minor(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Session_Init::VT_VERSION_MINOR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn session_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Session_Init::VT_SESSION_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn crypto_key(&self) -> Option<flatbuffers::Vector<'a, i8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i8>>>(Session_Init::VT_CRYPTO_KEY, None)}
  }
  #[inline]
  pub fn do_hash(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Session_Init::VT_DO_HASH, Some(false)).unwrap()}
  }
  #[inline]
  pub fn do_crypto(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Session_Init::VT_DO_CRYPTO, Some(false)).unwrap()}
  }
  #[inline]
  pub fn do_verbose(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Session_Init::VT_DO_VERBOSE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn do_compression(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Session_Init::VT_DO_COMPRESSION, Some(false)).unwrap()}
  }
  #[inline]
  pub fn do_preserve(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Session_Init::VT_DO_PRESERVE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn do_sparse(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Session_Init::VT_DO_SPARSE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn no_direct(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Session_Init::VT_NO_DIRECT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn is_error(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Session_Init::VT_IS_ERROR, Some(false)).unwrap()}
  }
  #[inline]
  pub fn log_file(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Session_Init::VT_LOG_FILE, None)}
  }
  #[inline]
  pub fn message(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Session_Init::VT_MESSAGE, None)}
  }
  #[inline]
  pub fn bind_interface(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Session_Init::VT_BIND_INTERFACE, None)}
  }
  #[inline]
  pub fn port_start(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Session_Init::VT_PORT_START, Some(0)).unwrap()}
  }
  #[inline]
  pub fn port_end(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Session_Init::VT_PORT_END, Some(0)).unwrap()}
  }
  #[inline]
  pub fn io_engine(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Session_Init::VT_IO_ENGINE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn thread_count(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Session_Init::VT_THREAD_COUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn block_sz(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Session_Init::VT_BLOCK_SZ, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ip_mode(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Session_Init::VT_IP_MODE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Session_Init<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("version_major", Self::VT_VERSION_MAJOR, false)?
     .visit_field::<i32>("version_minor", Self::VT_VERSION_MINOR, false)?
     .visit_field::<u64>("session_id", Self::VT_SESSION_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i8>>>("crypto_key", Self::VT_CRYPTO_KEY, false)?
     .visit_field::<bool>("do_hash", Self::VT_DO_HASH, false)?
     .visit_field::<bool>("do_crypto", Self::VT_DO_CRYPTO, false)?
     .visit_field::<bool>("do_verbose", Self::VT_DO_VERBOSE, false)?
     .visit_field::<bool>("do_compression", Self::VT_DO_COMPRESSION, false)?
     .visit_field::<bool>("do_preserve", Self::VT_DO_PRESERVE, false)?
     .visit_field::<bool>("do_sparse", Self::VT_DO_SPARSE, false)?
     .visit_field::<bool>("no_direct", Self::VT_NO_DIRECT, false)?
     .visit_field::<bool>("is_error", Self::VT_IS_ERROR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("log_file", Self::VT_LOG_FILE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("message", Self::VT_MESSAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("bind_interface", Self::VT_BIND_INTERFACE, false)?
     .visit_field::<i32>("port_start", Self::VT_PORT_START, false)?
     .visit_field::<i32>("port_end", Self::VT_PORT_END, false)?
     .visit_field::<i32>("io_engine", Self::VT_IO_ENGINE, false)?
     .visit_field::<i32>("thread_count", Self::VT_THREAD_COUNT, false)?
     .visit_field::<i32>("block_sz", Self::VT_BLOCK_SZ, false)?
     .visit_field::<u8>("ip_mode", Self::VT_IP_MODE, false)?
     .finish();
    Ok(())
  }
}
pub struct Session_InitArgs<'a> {
    pub version_major: i32,
    pub version_minor: i32,
    pub session_id: u64,
    pub crypto_key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i8>>>,
    pub do_hash: bool,
    pub do_crypto: bool,
    pub do_verbose: bool,
    pub do_compression: bool,
    pub do_preserve: bool,
    pub do_sparse: bool,
    pub no_direct: bool,
    pub is_error: bool,
    pub log_file: Option<flatbuffers::WIPOffset<&'a str>>,
    pub message: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bind_interface: Option<flatbuffers::WIPOffset<&'a str>>,
    pub port_start: i32,
    pub port_end: i32,
    pub io_engine: i32,
    pub thread_count: i32,
    pub block_sz: i32,
    pub ip_mode: u8,
}
impl<'a> Default for Session_InitArgs<'a> {
  #[inline]
  fn default() -> Self {
    Session_InitArgs {
      version_major: 0,
      version_minor: 0,
      session_id: 0,
      crypto_key: None,
      do_hash: false,
      do_crypto: false,
      do_verbose: false,
      do_compression: false,
      do_preserve: false,
      do_sparse: false,
      no_direct: false,
      is_error: false,
      log_file: None,
      message: None,
      bind_interface: None,
      port_start: 0,
      port_end: 0,
      io_engine: 0,
      thread_count: 0,
      block_sz: 0,
      ip_mode: 0,
    }
  }
}

pub struct Session_InitBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Session_InitBuilder<'a, 'b> {
  #[inline]
  pub fn add_version_major(&mut self, version_major: i32) {
    self.fbb_.push_slot::<i32>(Session_Init::VT_VERSION_MAJOR, version_major, 0);
  }
  #[inline]
  pub fn add_version_minor(&mut self, version_minor: i32) {
    self.fbb_.push_slot::<i32>(Session_Init::VT_VERSION_MINOR, version_minor, 0);
  }
  #[inline]
  pub fn add_session_id(&mut self, session_id: u64) {
    self.fbb_.push_slot::<u64>(Session_Init::VT_SESSION_ID, session_id, 0);
  }
  #[inline]
  pub fn add_crypto_key(&mut self, crypto_key: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Session_Init::VT_CRYPTO_KEY, crypto_key);
  }
  #[inline]
  pub fn add_do_hash(&mut self, do_hash: bool) {
    self.fbb_.push_slot::<bool>(Session_Init::VT_DO_HASH, do_hash, false);
  }
  #[inline]
  pub fn add_do_crypto(&mut self, do_crypto: bool) {
    self.fbb_.push_slot::<bool>(Session_Init::VT_DO_CRYPTO, do_crypto, false);
  }
  #[inline]
  pub fn add_do_verbose(&mut self, do_verbose: bool) {
    self.fbb_.push_slot::<bool>(Session_Init::VT_DO_VERBOSE, do_verbose, false);
  }
  #[inline]
  pub fn add_do_compression(&mut self, do_compression: bool) {
    self.fbb_.push_slot::<bool>(Session_Init::VT_DO_COMPRESSION, do_compression, false);
  }
  #[inline]
  pub fn add_do_preserve(&mut self, do_preserve: bool) {
    self.fbb_.push_slot::<bool>(Session_Init::VT_DO_PRESERVE, do_preserve, false);
  }
  #[inline]
  pub fn add_do_sparse(&mut self, do_sparse: bool) {
    self.fbb_.push_slot::<bool>(Session_Init::VT_DO_SPARSE, do_sparse, false);
  }
  #[inline]
  pub fn add_no_direct(&mut self, no_direct: bool) {
    self.fbb_.push_slot::<bool>(Session_Init::VT_NO_DIRECT, no_direct, false);
  }
  #[inline]
  pub fn add_is_error(&mut self, is_error: bool) {
    self.fbb_.push_slot::<bool>(Session_Init::VT_IS_ERROR, is_error, false);
  }
  #[inline]
  pub fn add_log_file(&mut self, log_file: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Session_Init::VT_LOG_FILE, log_file);
  }
  #[inline]
  pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Session_Init::VT_MESSAGE, message);
  }
  #[inline]
  pub fn add_bind_interface(&mut self, bind_interface: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Session_Init::VT_BIND_INTERFACE, bind_interface);
  }
  #[inline]
  pub fn add_port_start(&mut self, port_start: i32) {
    self.fbb_.push_slot::<i32>(Session_Init::VT_PORT_START, port_start, 0);
  }
  #[inline]
  pub fn add_port_end(&mut self, port_end: i32) {
    self.fbb_.push_slot::<i32>(Session_Init::VT_PORT_END, port_end, 0);
  }
  #[inline]
  pub fn add_io_engine(&mut self, io_engine: i32) {
    self.fbb_.push_slot::<i32>(Session_Init::VT_IO_ENGINE, io_engine, 0);
  }
  #[inline]
  pub fn add_thread_count(&mut self, thread_count: i32) {
    self.fbb_.push_slot::<i32>(Session_Init::VT_THREAD_COUNT, thread_count, 0);
  }
  #[inline]
  pub fn add_block_sz(&mut self, block_sz: i32) {
    self.fbb_.push_slot::<i32>(Session_Init::VT_BLOCK_SZ, block_sz, 0);
  }
  #[inline]
  pub fn add_ip_mode(&mut self, ip_mode: u8) {
    self.fbb_.push_slot::<u8>(Session_Init::VT_IP_MODE, ip_mode, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Session_InitBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Session_InitBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Session_Init<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Session_Init<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Session_Init");
      ds.field("version_major", &self.version_major());
      ds.field("version_minor", &self.version_minor());
      ds.field("session_id", &self.session_id());
      ds.field("crypto_key", &self.crypto_key());
      ds.field("do_hash", &self.do_hash());
      ds.field("do_crypto", &self.do_crypto());
      ds.field("do_verbose", &self.do_verbose());
      ds.field("do_compression", &self.do_compression());
      ds.field("do_preserve", &self.do_preserve());
      ds.field("do_sparse", &self.do_sparse());
      ds.field("no_direct", &self.no_direct());
      ds.field("is_error", &self.is_error());
      ds.field("log_file", &self.log_file());
      ds.field("message", &self.message());
      ds.field("bind_interface", &self.bind_interface());
      ds.field("port_start", &self.port_start());
      ds.field("port_end", &self.port_end());
      ds.field("io_engine", &self.io_engine());
      ds.field("thread_count", &self.thread_count());
      ds.field("block_sz", &self.block_sz());
      ds.field("ip_mode", &self.ip_mode());
      ds.finish()
  }
}
